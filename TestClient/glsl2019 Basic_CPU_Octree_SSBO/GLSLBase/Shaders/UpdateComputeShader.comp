#version 450
layout(local_size_x = 8, local_size_y = 1, local_size_z = 1) in;

// Data Packing
// word 단위
struct Vertex{
	vec3 pos;
	float speed;
	vec3 dir;
	float collide_time;
};

struct Node {
	vec3 pos;
	float radius;
	ivec4 info;
	ivec4 vertexRef[2048];
};

bool IsInNode(vec3 nodePos, float nodeWidth, const vec3 pos)
{
	vec3 aabbMin;
	vec3 aabbMax;

	aabbMin = nodePos - vec3(nodeWidth * 0.5f);
	aabbMax = nodePos + vec3(nodeWidth * 0.5f);

	bool inside = false;
	if (aabbMin.x <= pos.x && aabbMax.x >= pos.x &&
		aabbMin.y <= pos.y && aabbMax.y >= pos.y &&
		aabbMin.z <= pos.z && aabbMax.z >= pos.z) {
		inside = true;
	}

	return inside;
}

layout (std430, binding = 0) buffer a_Particle{
	Vertex particles[];
};

layout (std430, binding = 1) buffer NodeBuffer{
	Node nodes[];
};

uniform float u_Time;
uniform sampler2D u_NodeTexture;

const vec3 g_gravity = vec3(0, -1, 0);

void main()
{
	uint index = gl_GlobalInvocationID.x;
	Vertex mVertex = particles[index];

	//mVertex.pos = mVertex.pos + ((mVertex.dir * mVertex.speed) + (g_gravity * u_Time * mVertex.speed));

	ivec2 pixel = ivec2(0,0); // Root
	bool foundLeaf = false;
	int depthCounter = 0;
	int nodeIndex = 0;
	
	float particle_min_length = 10000.0f;
	vec3 particle_collide_pos;
	bool particle_collision = false;

	// 파티클이 현재 노드안에 있으면
	if(IsInNode(nodes[0].pos, nodes[0].radius, mVertex.pos)){
		
		bool foundChild = false;
		
		// Leaf 노드까지 반복
		while(!foundLeaf){
	
			vec4 parentData = texelFetch(u_NodeTexture, pixel, 0);
			pixel = ivec2(parentData.x, parentData.y); // x and y are the offset to the children in the texture.
			foundChild = false;
	
			// parentData.z == 8
			for(int i = 0; i < int(parentData.z); i++){
				// Texture (250 x 250) 순환
				if(i > 0){
				// Texture 자식노드좌표
				// 다음 루프용으로 증가시키는 것
					pixel.x += 1;
					pixel.y += (pixel.x / 250);
					pixel.x %= 250;
				}
				// parentData.w
				// == oneDimensionalOffset
				if(IsInNode(nodes[int(parentData.w) + i].pos, nodes[int(parentData.w) + i].radius, mVertex.pos)){
					nodeIndex = int(parentData.w) + i;
					foundChild = true;
					break;
				}
			}
			
			if(foundChild == false){
				break;
			}
	
			// node.info.z == isLeaf (bool type)
			if(nodes[nodeIndex].info.z == 1){
				foundLeaf = true;
				break;
			}
		}
	}

	if(foundLeaf){
		Node leaf = nodes[nodeIndex];
		
		mVertex.collide_time = leaf.info.x;
	
		// leaf info.x == Leaf Node의 파티클 개수
		for(int i = 0; i < leaf.info.x; ++i)
		{
			mVertex.collide_time = 10.0f;
			Vertex object = particles[leaf.vertexRef[i].x];
			
			float len = length(mVertex.pos.xyz - object.pos.xyz);
			if (100.0f > len && len < particle_min_length) {
				particle_min_length = len;
				particle_collide_pos = object.pos;
				particle_collision = true;
			}
		}
	}

	if(particle_collision == true)
	{
		mVertex.dir = normalize(mVertex.pos.xyz - particle_collide_pos.xyz);
		mVertex.speed = mVertex.speed * 0.2f;
		mVertex.collide_time = 10.0f;
		mVertex.pos = mVertex.pos + ((mVertex.dir * mVertex.speed) + (u_Time * mVertex.speed));
	}
	else 
	{
		vec3 temp = (mVertex.dir * mVertex.speed);
		mVertex.dir = normalize(temp);
		mVertex.speed = length(temp);
		mVertex.collide_time = mVertex.collide_time - u_Time * mVertex.speed;
		mVertex.pos = mVertex.pos + ((mVertex.dir * mVertex.speed) + (g_gravity * u_Time * mVertex.speed));
	}

	particles[index].pos = mVertex.pos;
	particles[index].dir = mVertex.dir;
	particles[index].speed = mVertex.speed;
	particles[index].collide_time = mVertex.collide_time;
}