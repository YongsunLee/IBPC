#version 450
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

struct Vertex {
	vec3 pos;
	vec3 dir;
	float speed;
	float collide_time;
};

struct Node {
	vec3 pos;
	float radius;
	ivec4 info; // Node information: x = nrOfTriangles, y = number of active children, z = is node a leaf node? 
	ivec4 vertexRef[2048]; // 
};

bool IsInNode(vec3 nodePos, float nodeWidth, const vec3 pos)
{
	vec3 aabbMin;
	vec3 aabbMax;

	aabbMin = nodePos - vec3(nodeWidth);
	aabbMax = nodePos + vec3(nodeWidth);

	bool inside = false;
	if (aabbMin.x <= pos.x && aabbMax.x >= pos.x &&
		aabbMin.y <= pos.y && aabbMax.y >= pos.y &&
		aabbMin.z <= pos.z && aabbMax.z >= pos.z) {
		inside = true;
	}

	return inside;
}


layout (std430, binding = 0) buffer a_Pos{
	vec3 pos[];
};


layout (std430, binding = 1) buffer a_Dir{
	vec3 dir[];
};

layout (std430, binding = 2) buffer a_Speed{
	float speed[];
};

layout (std430, binding = 3) buffer a_CollideTime{
	float collideTime[];
};

layout (std430, binding = 4) readonly buffer NodeBuffer{
	Node nodes[];
};

layout (std430, binding = 5) buffer VertexBuffer{
	Vertex vertex[];
};

uniform sampler2D u_NodeTexture;
uniform float u_Time;

const vec3 g_gravity = vec3(0, -1, 0);

void main()
{
	uint index = gl_GlobalInvocationID.x;
	vec3 aPos = pos[index];
	vec3 aDir = dir[index];
	float aSpeed = speed[index];
	float aCollideTime = collideTime[index];

	//aPos = aPos + ((aDir * speed) + (g_gravity * u_Time * speed));

	ivec2 pixel = ivec2(0,0); // Root
	bool foundLeaf = false;
	int depthCounter = 0;
	int nodeIndex = 0;
	

	// 파티클이 현재 노드안에 있으면
	if(IsInNode(nodes[0].pos, nodes[0].radius, aPos)){
		
		bool foundChild = false;
		
		// Leaf 노드까지 반복
		while(!foundLeaf){
	
			vec4 parentData = texelFetch(u_NodeTexture, pixel, 0);
			pixel = ivec2(parentData.x, parentData.y); // x and y are the offset to the children in the texture.
			foundChild = false;
	
			// parentData.z 
			// == trisIndices.size()
			for(int i = 0; i < int(parentData.z); i++){
				// Texture (250 x 250) 순환
				if(i > 0){
				// Texture 자식노드좌표
				// 다음 루프용으로 증가시키는 것
					pixel.x += 1;
					pixel.y += (pixel.x / 250);
					pixel.x %= 250;
				}
				// parentData.w
				// == oneDimensionalOffset
				if(IsInNode(nodes[int(parentData.w) + i].pos, nodes[int(parentData.w) + i].radius, aPos)){
					nodeIndex = int(parentData.w) + i;
					foundChild = true;

					
					break;
				}
			}
			
			if(foundChild == false){
				break;
			}
	
			// node.info.z == isLeaf (bool type)
			if(nodes[nodeIndex].info.z == 1){
				foundLeaf = true;
				break;
			}
		}
	}

	if(foundLeaf){
		// Leaf Node의 파티클 개수
		Node leaf = nodes[nodeIndex];
		for(int i = 0; i < leaf.info.x; ++i)
		{
			Vertex object = vertex[leaf.vertexRef[i].x];
			
			float len = length(aPos.xyz - object.pos.xyz);
			if( 10.f > len )
			{
				aDir = normalize(aPos.xyz - object.pos.xyz);

				//object.dir =normalize(object.pos.xyz = aPos.xyz);
				//object.speed = object.speed * 0.2f;
				//object.pos = object.pos + (object.dir * object.speed);
				//object.collide_time = 10.0f;

				aSpeed = aSpeed * 0.2f;
				aCollideTime = 10.0f;
			}
		}
	}
	
	//aPos = aPos + (g_gravity * u_Time);
	
	aPos = aPos + ((aDir * aSpeed)); // + (g_gravity * u_Time * aSpeed));

	pos[index] = aPos;
	dir[index] = aDir;
	speed[index] = aSpeed;
	collideTime[index] = aCollideTime;

}