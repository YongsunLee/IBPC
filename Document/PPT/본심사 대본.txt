-15분 정도-

[1 제목]
안녕하세요. 
이미지 기반 파티클 충돌 처리 시스템을 발표할
미디어융합디자인 대학원 석사과정 이용선 발표를 시작하겠습니다.

[2 개요]
일반적으로 게임에서 사용되는 파티클 충돌이란 파티클과 오브젝트간의 충돌을 의미합니다.
이러한 파티클과 오브젝트간의 충돌은 여러 연구가 진행되어 왔으며 
화면에서 보이는 그림처럼 상용 게임 엔진에서도 사용하는 것을 확인할 수 있습니다.

[3 관련연구]
그러나 실시간 환경에서의 파티클과 파티클 사이의 충돌에 대해서는 여러가지 문제점이 있습니다.

Octree 방식과 Screen Space Particle Collision의 파티클과 오브젝트의 충돌 성능을 비교한 연구에서는

Octree 방식이 파티클간의 충돌처리를 진행할 수 있으나 파티클의 개수에 따라 실시간 렌더링에서는 성능적으로 한계가 나타날 수 있으며, 
SSPC방식은 파티클간의 충돌처리에 사용할 수 없다는 단점이 있다고 설명하였습니다.

[4 연구목적]
본 논문의 연구 목적은 게임과 같은 실시간 렌더링 환경에서의 파티클간의 충돌처리를 목표로 합니다.

이때 목표로 하는 충돌처리는 정확한 수준의 충돌처리가 아닌 이해할 만한 수준의 충돌처리를 목표로 하며,

이해할 만한 수준의 충돌처리란 시점의 변화가 큰 경우나, 가려진 파티클들이 많은 경우 충돌처리 과정에서 생략됨을 의미합니다.


[5 시스템 설계]
시스템 설계에 대해 말씀드리겠습니다.

본 논문에서 제안하는 알고리즘은 충돌 단계와 렌더 단계 두 단계로 나누어져 있습니다.

충돌 단계에서는 파티클의 충돌처리와 정보 업데이트, 그리고 충돌 감지 텍스처를 업데이트 합니다.

다음으로 렌더 단계에서는 충돌 단계에서 갱신된 파티클의 정보를 이용하여 빌보드 파티클 렌더링을 수행합니다.


[6]
충돌 단계에서는 입력된 데이터를 Vertex Shader에서 충돌을 처리하고 정보를 업데이트합니다.
이렇게 갱신된 정보는 Geometry Shader에서 Transform Feedback을 통해 Transform Feedback Buffer Object에 갱신됩니다.
Fragment Shader에서 파티클의 3차원 위치 정보를 컬러코드로 변환하여 충돌 감지 텍스처를 갱신합니다.

[7]
렌더링 단계에서는 충돌 단계에서 업데이트된 Transform Feedback Buffer Object을 입력으로 사용합니다.

Geometry Shader에서 입력된 정점을 Quad 형태의 도형으로 변형시키고 카메라를 바라보는 기능을 추가하여 Billboard 형태로 렌더링합니다.

[8 - TF]
충돌 단계와 렌더 단계의 설명에서 볼 수 있듯이 본 논문의 시스템에서는 Transform Feedback 이라는 기능을 사용하고 있습니다. 

해당 기능은 사전에 베어링으로 설정한 데이터를 GPU의 버텍스 셰이더 또는 지오메트리 셰이더의 아웃풋을 
Transform Feedback Buffer Object로 갱신할 수 있도록 하는 기능으로 

파티클 시스템에 CPU의 간섭을 최소한으로 하여 GPU에서 연산을 진행할 수 있도록 사용하였습니다.

본 논문에서 베어링으로 설정한 변수는 파티클의 위치, 방향, 속도, 충돌 시간을 갱신하는데 사용하였습니다.

또한, 읽기, 쓰기 과정에서 일어날 수 있는 충돌을 피하기 위해 두개의 버퍼를 사용하여 
매 프레임마다 서로의 역할을 바꾸어 최신 정보를 기반으로 계산되도록 하였습니다.

[9 - CDT]
다음으로 충돌 감지 텍스처에 대해 말씀드리겠습니다.

충돌 처리에 사용되는 충돌 감지 텍스처는 카메라를 통해 생성되는
파티클의 3차원 위치 정보를 컬러코드로 변환하여 저장한 2차원 형태의 텍스처를 의미합니다.

충돌 처리 또는 중력의 영향으로 인해 업데이트된 파티클의 3차원 위치 정보를 프래그먼트 셰이더에서 RGB 값으로 변환하여 작성한 텍스처입니다.


[10 - 충돌처리]
본 논문의 첫 프레임에서는 충돌감지 텍스처에 아무런 데이터가 없어 충돌처리가 진행되지 않으며
충돌 감지 텍스처에 파티클들의 위치 정보가 입력됩니다.

충돌 감지 텍스처가 생성된 첫 프레임 이후의 파티클 충돌처리는 다음과 같습니다.
현재 그래픽스 파이프라인에 입력된 정점 정보를 정수형 2차원 인덱스로 변형시킵니다.

이렇게 구해진 Base Texel를 OpenGL에서 제공하는 texelFectch 함수를 사용하여 충돌 감지 텍스처에 저장된 3차원 위치 정보를 샘플링 합니다.
샘플링해서 얻어진 현재 파티클의 위치를 curr_pos 변수에 저장합니다.


[11 - 충돌처리]
그 다음 주변 파티클의 3차원 위치 정보를 샘플링하기 위해서 base texel 변수를 기준으로 2중 반복문을 순환하며 샘플링을 진행합니다.

2중 반복문을 순환하기전 가장 가까운 파티클을 탐색하기 위해 최소거리를 저장하는데 사용할 particle_min_length(파티클 민 랭스) 변수를 선언하였습니다.

또한, 충돌로 판정할 거리를 설정한 g_collision_range (콜리젼 레인지) 변수를 선언하였습니다.

이후 2중 반복문을 순회하는데 이때 반복문의 조건변수 tx, ty는 미리 설정해둔 상수 값인 
texel_collide_range(텍셀 콜라이드 레인지)의 음수부터 양수까지의 범위를 가지게 됩니다.

두 조건변수는 –texel_collide_range의 값을 초기값으로 가지고 반복되는 동안 1씩 증가시켜 
양수의 texel_collide_range의 범위까지 순환하게 됩니다.

반복문의 조건변수 tx, ty가 base texel과 같아지는 0의 값을 가지는 경우 충돌 처리를 하지 않으며,
그 외의 경우에는 base texel 변수에 tx, ty 값을 더하여 새로운 2차원 인덱스를 계산하여 해당 인덱스의 3차원 위치 정보를 구합니다.

계산된 3차원 위치 정보와 curr_pos 변수에 저장된 3차원 위치 값을 length 함수를 이용하여 직선거리를 계산합니다.

이 값이 particle_min_length 변수보다 작고, g_collision_range 값보다 작은 경우 충돌로 판정하여 particle_min_length 변수를 갱신하고 현재 파티클이 충돌되었음을 기록합니다.

오른쪽의 그림은 texel_collide_range 변수를 1로 설정했을때의 충돌 감지 범위를 보여주는 그림입니다.


[12 - 충돌처리]
이후 충돌된 파티클의 위치, 속도, 방향 그리고 충돌 시간을 갱신합니다.
충돌 판정된 파티클은 속도를 20% 감소시키고, 
방향은 두 파티클의 3차원 위치 정보의 뺄셈을 통해 얻어지는 벡터를 정규화 한 값을 사용하였습니다.
3차원 위치 정보는 갱신된 속도와 방향을 곱하여 이전의 3차원 위치 정보에 더하여 갱신하였습니다.
파티클의 시각적 표시 및 지속적인 충돌 방지를 위해 충돌시간을 기록하여 저장합니다.

충돌되지 않은 파티클은 중력에 의해 위치, 속도, 방향이 업데이트됩니다.

업데이트된 모든 정보는 기하 셰이더에서 Transform Feedback Buffer에 기록됩니다.


[13 - 렌더단계]
렌더 단계에서는 충돌 단계에서 업데이트된 
Transform Feedback Buffer를 이용하여 파티클의 렌더링을 진행합니다.

입력된 하나의 정점을 기하 셰이더를 통해 Quad 형태의 도형으로 변형시키고 
이를 빌보드 기능을 추가하여 화면에 렌더링합니다.

[14 - 벤치마크 환경]
본 논문에서 제안한 파티클 충돌 방식의 성능 측정방법을 위해 사용된 벤치마크 환경은 다음과 같습니다.

GPU는 엔비디아사의 RTX 2060을 통해 진행하였으며
충돌 감지 텍스처의 해상도는 가로, 세로 500 픽셀을 지정하였습니다.

그리고 실제 게임에서는 파티클의 라이프타임이 매우 짧게 설정되어 사용되지만
본 논문의 연구에서는 성능 측정을 위해 파티클의 라이프타임을 배제하여 성능을 측정하였습니다.

[15 - 성능 측정 방법]
본 논문에서 제안한 파티클 충돌 방식의 성능 측정을 위해 두가지 방식을 사용하였습니다.

첫번째 방식으로 모델이 없는 Scene에서 x축으로 이동하는 파티클의 개수를 변경하는 방식이며
두번째 방식으로 모델이 있는 Scene에서 중력을 통해 떨어지는 파티클의 개수와 밀도를 변경하는 방식을 사용하였습니다.

첫번째 방식과 두번째 방식 모두 파티클의 개수는 5만개 부터 20만개로 5만개 단위로 증가시켜가며 측정하였습니다.

또한, 두번째 방식에서 파티클의 밀도는 A타입과 B타입 두가지를 이용하여 측정하였습니다.
사용하는 모델은 토끼 모델과 용 모델 두가지를 사용하였습니다.

성능 측정은 ms 단위로 측정하였으며 가장 높은 ms 값을 기준으로 측정하였습니다.


[16 - 결과(X축 파티클 충돌)]
첫번째로, 그림과 같이 X축으로 움직이는 파티클의 충돌을 이용하여 비교하였습니다.

[17 - 결과(X축 파티클 충돌)]
파티클의 개수는 5만개 부터 20만개의 파티클을 충돌시켰습니다.

평균적으로 이미지 기반 충돌처리 시스템은 99.75ms(소수점 아래 자리를 제외하고 99ms)의 값을 가지며
옥트리 기반 충돌처리 시스템은 171.75ms(소수점 아래 자리를 제외하고 171ms)의 값을 가지는 것을 확인하였습니다.

[18 - 결과(모델 파티클 충돌)]
두번째로 모델이 있는 Scene에서의 파티클 충돌입니다.

영상은 A타입의 밀도에서 토끼 모델과 용 모델을 사용하였을 때의 10만개의 파티클 충돌 결과입니다.

[19 - 결과(카메라 이동)]
이전 영상과 같은 세팅으로 파티클의 개수와 밀도를 변경하며 실험을 진행하고 요약한 결과를 차트로 정리하였습니다.

왼쪽의 차트는 토끼 모델을 사용했을 때의 결과를 보여주는 차트이며

오른쪽의 차트는 용 모델을 사용했을 때의 결과를 보여주는 차트입니다.

두 결과 모두 파티클의 개수에 따라 ms가 선형적으로 증가하는 것을 볼 수 있으며

모델이 주는 영향이 미세한 것으로 볼 수 있었습니다.


[20 - 결과(토끼 표)]
같은 방식을 이용하여 옥트리 충돌처리 시스템의 충돌 결과를 정리하였습니다.

왼쪽 영상에서 볼 수 있듯이 B밀도를 가지는 파티클을 충돌시켰습니다.
20만개의 파티클의 결과를 모델별로 차트로 정리하였습니다.

본논문에서 제안한 방식과 동일하게 크게 작용하지 않음을 알 수 있으며 
ms가 선형적으로 증가하는 것을 확인할 수 있습니다.


[21 - 결과(용 표)]
본 논문에서 제안한 충돌방식과 옥트리 충돌방식의 결과를 차트로 정리하였습니다.

두 방식 모두 파티클의 개수에 따라 ms 가 선형적으로 증가하였으나

본 논문에서 제안하는 알고리즘보다 옥트리 충돌 방식의 ms 값이 높은 것을 확인할 수 있었습니다.

결과적으로 
본 논문에서 제안하는 알고리즘이 옥트리 충돌 방식보다 성능 면에서 향상된 ms를 보여주는 것을 확인할 수 있었습니다.

[22 - 결과]
문제점 및 향후 연구입니다.

앞서 말씀드린 것과 같이 본 논문은 파티클의 3차원 위치 정보를 2차원 텍스처에 투영한 값을 이용하여 파티클 충돌을 처리합니다.

그렇기 때문에 정보의 손실이 일어나게 되며, 투영으로 인해 충돌할 파티클이 충돌하지 않거나
충돌해야 하는 파티클들이 충돌하지 않을 수 있습니다.

추후 연구에서는 정확도 개선을 위해 3D 볼륨 텍스처를 이용한 충돌 연구를 진행할 계획입니다.

이상으로 발표를 마치겠습니다. 감사합니다.
