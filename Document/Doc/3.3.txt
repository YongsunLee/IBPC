본 논문에서 소개하는 파티클 충돌처리 시스템 알고리즘은 충돌처리 패스와 렌더링 패스 2개의 그래픽스 파이프라인의 구조를 가지고 있다. 
첫번째 단계인 충돌 패스의 초기화 단계는 CPU를 통해 전달되는 정점 데이터를 사용하여 진행되는데 이 단계에서는 충돌 탐지 텍스처가 만들어지기 전 단계이기 때문에 빈 텍스처와의 처리가 진행되어 충돌이 일어나지 않는다. 기하 셰이더에서 Transfrom Feedback 기능을 통해 업데이트된 파티클의 데이터가 Transform Feedback Buffer Object에 작성된다. 프래그먼트 셰이더를 통해 충돌 탐지 텍스처에 파티클의 위치를 기록하여 생성한다.
초기화가 끝난 충돌처리 패스는 Figure 3와 같은 구조를 통해 진행된다. Transform Feedback을 통해 기하 셰이더에서 지속적으로 두개의 Transform Feedback Buffer Object를 입력과 출력으로 번갈아가며 갱신되는 값을 입력 데이터로 이용하여 진행된다. Buffer Object에 기록되는 데이터로는 파티클의 위치, 방향, 속도, 충돌시간을 포함한다. 초기화 이후의 프레임이므로 충돌 탐지 텍스처가 생성되어 있기 때문에 정점 셰이더에서 충돌 시스템이 작동한다. 충돌 시스템은 다음의 순서로 진행된다.
정점 셰이더에 입력된 정점의 포지션 값에 카메라에서 받아온 뷰 프로젝션 행렬을 곱하여 동차좌표로 변경한다. 변경된 위치값의 x,y좌표를 변형하여 정규화된 텍스처 좌표를 얻는다. 
얻어진 텍스처 좌표값에 충돌 탐지 텍스처의 가로, 세로 해상도 값을 곱해 정규화되지 않은 현재 파티클의 텍셀 좌표를 구한다.

텍셀을 통해 texelFectch 함수를 이용하여 충돌 감지 텍스처에 저장된 현재 파티클의 위치 값을 읽어온다. 미리 설정된 충돌 탐색 범위를 반복문을 통하여 샘플링하며 해당 범위 내에 파티클 위치 값을 변환하여 현재의 파티클의 위치와의 거리를 계산하여 비교한다. 그중 가장 작은 값과 충돌을 진행한다.
충돌이 진행된 파티클은 속도를 20% 감소시키고, 충돌한 파티클과 현재 파티클의 위치를 계산해서 파티클의 방향을 바꾸어주며 같은 파티클과의 지속적인 충돌을 없애기 위해 추가한 충돌시간을 업데이트한다. 마지막으로 변경된 방향과 속도를 이용하여 파티클의 위치를 변경한다. 충돌하지 않은 파티클은 설정해놓은 중력값을 이용하여 파티클의 속도 및 방향 그리고 위치를 변경한다. 이 과정을 의사코드로 표현하면 다음과 같다.

ParticleCollision
loop particle in scene.particle
vec4 gl_Position = u_ProjView * vec4(a_Position,1)
vec2 TexCoord = (gl_Position.xy + vec2(1)) * 0.5
ivec2 texel_base = ivec2(TexCoord.x * u_ClientWidth, TexCoord.y * u_ClientHeight)
vec4 curr_pos = texelFectch(u_CDTxture, texel_base, 0)
float particle_min_length = 100000
if a_CollideTime < 0 
loop ty in -texel_collide_range <= ty <= texel_collide_range
loop tx in -texel_collide_range <= tx <= texel_collide_range
ivec2 texel = texel_base + ivec2(tx, ty)
if tx == 0 && ty == 00
continue
vec4 particle_pos = texelFetch(u_CDTexture, texel, 0)
float len = length(curr_pos.xyz – particle_pos.xyz)
if g_collision_range > len && len < particle_min_length 
particle_min_length = len
particle_collide_pos = particle_pos
particle_collision = true
if particle_collision == true 
f_Speed = a_Speed * 0.2
v_Dir = normalize(curr_pos.xyz – particle_collide_pos.xyz)
f_CollideTime = g_collision_time
v_Position = a_Position + (v_Dir * f_Speed)
else
vec3 temp = (a_Dir * a_Speed) + (g_gravity * g_tick)
v_Dir = normalize(temp)
f_Speed = length(temp)
f_CollideTime = a_CollideTime – g_tick
v_Position = a_Position + (v_Dir * f_Speed) * g_tick

렌더링 패스의 구조는 Figure 3와 같다. 
렌더링 패스는 충돌 처리 패스를 통해 업데이트된 Transform Feedback Buffer Object를 렌더링 패스의 정점 셰이더의 입력 데이터로 활용한다. 렌더링 패스의 정점 셰이더는 입력 받은 데이터를 특별히 가공하지 않고 포지션 값에 w값을 추가하여 기하 셰이더에 전달한다. 
기하 셰이더에서는 입력된 하나의 정점을 빌보드 형태로 변형시키는 작업을 진행한다. 입력받은 정점을 기준으로 카메라를 바라보는 4개의 정점을 생성하며 해당 정점들에 뷰 프로젝션 행렬을 곱하여 동차좌표로 변환시킨다.
빌보드 형태로 변환된 정점 데이터는 프래그먼트 셰이더에서 충돌 시간이 양수인경우 빨간색 색상값을 주어 화면에 렌더링하고 그외의 경우 녹색으로 렌더링하였다.






