기존의 파티클 충돌처리 방식은 실시간으로 렌더링하기에는 많은 문제점을 가지고 있다. 
특히, 파티클들이 서로 부딪히며 튕겨 나가는 충돌처리의 경우 파티클 개수가 많아질수록 계산량이 급격하게 늘어나는 문제가 발생한다. 
실시간 렌더링 환경에서는 계산량을 줄이기 위해 파티클 개수를 줄이거나 특정 지오메트리와의 충돌처리만 처리하는 경우가 많다. 
본 논문에서는 파티클이 화면에 그려지는 월드공간 위치를 저장한 충돌 감지 텍스처(Collision Detection Texture)를 만들고 이전 프레임에 만들어진 충돌 감지 텍스처를 정점쉐이더(Vertex Shader)에서 현재 파티클의 텍셀(Texel)을 얻어 주변 텍셀들을 샘플링하여 충돌을 처리한다. 
제안된 방법은 프로그램 가능한 그래픽스 파이프라인(Vertex Shader, Geometry Shader, Fragment Shader)을 기반으로 구현하였으며 파티클의 개수가 많아도 파티클당 충돌처리를 O(n) (화면에 존재하는 파티클 개수 * 샘플링하는 텍셀 개수) 복잡도로 끝마칠 수 있다. 결과적으로 실험을 통해서 평균 71ms 이내에 125,000개의 파티클 충돌 처리를 진행할 수 있었다.

In existence particle collision methods have many problems to rendering in Real-time. Especially, in the case of a collision process in which the particles bounce off each other, a problem arises that the amount of calculation increases sharply as the number of particles increases. In a real-time rendering environment, we often reduce the number of particles or handle only collisions with specific geometry to reduce computation. In this paper, we create a Collision Detection Texture that stores the world space position where the particle is rendering on the screen, and then use the Collision Detection Texture created in the previous frame to obtain in the vertex shader the texel of the current paritcle and use the Texture Lookup function to obtain texel that surrounding current particle texel that use to collision processing. The proposed method is implementation based on a programmable graphics pipeline(Vertex Shader, Geometry Shdaer and Fragment Shader) and the collision of a large number of particles can be finished with the complexity of O(n) (the number of particles present on screen * the number of texels sampling). As a result, we could process 125,000 particle collisions within an average of 71ms.

------------------------------------------------------------------------------------------------- 2차 수정

TF http://blog.naver.com/PostView.nhn?blogId=gomdev&logNo=220262749994 

본 논문에서는 파티클과 오브젝트(Object)간의 충돌이 아닌 파티클과 파티클의 실시간 충돌 알고리즘을 제안한다. 해당 알고리즘은 두단계를 거친다. 첫 단계는 파티클의 업데이트 및 충돌을 처리하고 파티클의 월드 공간 위치(World Space Position)을 저장한 충돌 감지 텍스처(Collision Detection Texture)를 만든다. 초기화 단계에서는 CPU를 통해 정점 데이터(Vertex Data)를 입력으로 받으며 업데이트를 진행한다. 첫 프레임에는 충돌 감지 텍스처가 생성되지 않았기 때문에 충돌처리가 진행되지 않고 파티클의 업데이트만 진행한다. 

초기화 이후 프레임에서는 입력된 데이터에 뷰 프로젝션 행렬(View Projection Matrix)를 곱하여 동차좌표(Homogeneous Coordinates)로 변경한다. 변경된 데이터의 x,y 좌표를 변형하여 텍스처 좌표(Texture Coordinates)로 변환하고 해당 좌표 값에 충돌 감지 텍스처의 가로, 세로 해상도 크기를 곱하여 현재 입력된 파티클의 텍셀(Texel)을 얻는다. 텍셀을 이용하여 충돌 감지 텍스처에 저장된 파티클의 위치 값을 읽어온다. 현재 파티클 주변의 설정된 탐색 범위를 샘플링하며 해당 범위 내에 파티클의 위치 값을 변환하여 현재의 파티클 위치와의 거리를 계산하여 비교한다. 그중 가장 작은 값과 충돌을 진행한다. 충돌을 통해 변화되는 값은 업데이트 되어 다음 단계에서 입력으로 사용된다. 

두번째 단계는 첫번째 단계에서 업데이트된 정보를 이용하여 기하 셰이더(Geometry Shader)를 통해 빌보드 형태로 변형하여 파티클을 그려주는 단계를 거친다. 이때 충돌된 파티클의 색상을 변화시킨다. 사용한 파티클 시스템은 OpenGL의 Transform Feedback 기능을 이용하여 초기화를 제외하고 GPU에서 업데이트 된다. 해당 기능은 정점 셰이더(Vertex Shader)의 출력을 Transform Feedback Buffer Object로 지정한 Buffer Object에 Capturing 하게 되며, 해당 Output Buffer는 다음 그리기(draw)에 정점 데이터의 입력으로 사용하여 GPU를 통한 업데이트를 진행할 수 있도록 한다. 제안된 방법은 프로그램 가능한 그래픽스 파이프라인(Vertex Shader, Geometry Shader, Fragment Shader)을 기반으로 구현하였으며 파티클의 개수가 많아도 파티클당 충돌처리를 O(n) (화면에 존재하는 파티클 개수 * 샘플링하는 텍셀 개수) 복잡도로 끝마칠 수 있다. 결과적으로 실험을 통해서 평균 71ms 이내에 125,000개의 파티클 충돌 처리를 진행할 수 있었다.

In this paper, we propose a real-time collision algorithm of particles and particles, not collision between particles and objects. The algorithm goes through two steps. The first step is to create a collision detection texture that handles the update and collision of particles and stores the particle's world space position. In the initialization phase, the vertex data is received through the CPU as input and the update is performed. Since the collision detection texture is not generated in the first frame, collision processing does not proceed and only the particle is updated. 

After initialization, in the frame, the input data is changed to texture coordinates, and the coordinate values ​​are multiplied by the horizontal and vertical sizes of the collision detection texture to obtain the texel of the currently input particle. The position value stored in the collision detection texture is read using texel. The search range around the preset reference texel is sampled, and the position value is converted within the range to calculate and compare the distance to the current particle position. Collision with the smallest value. The values ​​that change through the collision are updated and used as input in the next step. 

The second step is to draw the particle by transforming it into a billboard form through a geometry shader using the updated information from the first step. At this time, the color of the collided particles is changed. The particle system used is updated on the GPU except for initialization using OpenGL's Transform Feedback function. This function captures the output of the vertex shader in the Buffer Object designated as the Transform Feedback Buffer Object, and the Output Buffer can be used as the input of vertex data for the next draw so that the update through the GPU can be performed. The proposed method is implementation based on a programmable graphics pipeline(Vertex Shader, Geometry Shdaer and Fragment Shader) and the collision of a large number of particles can be finished with the complexity of O(n) (the number of particles present on screen * the number of texels sampling). As a result, we could process 125,000 particle collisions within an average of 71ms.


------------------------------------------------------------------------------------------------- 3차 수정

본 논문에서는 파티클과 오브젝트(Object)간의 충돌이 아닌 파티클과 파티클의 실시간 충돌 알고리즘을 제안한다. 해당 알고리즘은 두단계를 거친다. 첫 단계는 파티클의 업데이트 및 충돌을 처리하고 파티클의 월드 공간 위치(World Space Position)을 저장한 충돌 감지 텍스처(Collision Detection Texture)를 만든다. 초기화 이후 프레임에서는 입력된 데이터를 변형하여 현재 입력된 파티클의 텍셀(Texel)을 얻는다. 텍셀을 이용하여 충돌 감지 텍스처에 저장된 파티클의 위치 값을 읽어온다. 현재 파티클 주변의 설정된 탐색 범위를 샘플링하며 해당 범위 내에 파티클의 위치 값을 변환하여 현재의 파티클 위치와의 거리를 계산하여 비교한다. 그중 가장 작은 값과 충돌을 진행한다. 충돌을 통해 변화되는 값은 업데이트 되어 다음 단계에서 입력으로 사용된다. 두번째 단계는 첫번째 단계에서 업데이트된 정보를 이용하여 기하 셰이더(Geometry Shader)를 통해 빌보드 형태로 변형하여 파티클을 그려주는 단계를 거친다. 이때 충돌된 파티클의 색상을 변화시킨다. 제안된 방법은 프로그램 가능한 그래픽스 파이프라인(Vertex Shader, Geometry Shader, Fragment Shader)을 기반으로 구현하였으며 파티클의 개수가 많아도 파티클당 충돌처리를 O(n) (화면에 존재하는 파티클 개수 * 샘플링하는 텍셀 개수) 복잡도로 끝마칠 수 있다. 결과적으로 실험을 통해서 평균 71ms 이내에 125,000개의 파티클 충돌 처리를 진행할 수 있었다.

In this paper, we propose a real-time collision algorithm of particles and particles, not collision between particles and objects. The algorithm goes through two steps. The first step is to create a collision detection texture that handles particle updates and collisions and stores the particle's world space position. In the frame after initialization, the input data is transformed to obtain the texel of the currently input particle. The position value of the particle stored in the collision detection texture is read using texel. The set search range around the current particle is sampled, and the position value of the particle is converted within the range to calculate and compare the distance to the current particle position. Conflicts with the smallest value. The values ​​that change through the collision are updated and used as input in the next step. The second step is to draw the particle by transforming it into a billboard shape through a geometry shader using the information updated in the first step. At this time, the color of the collided particles is changed. The proposed method is implementation based on a programmable graphics pipeline(Vertex Shader, Geometry Shdaer and Fragment Shader) and the collision of a large number of particles can be finished with the complexity of O(n) (the number of particles present on screen * the number of texels sampling). As a result, we could process 125,000 particle collisions within an average of 71ms.
