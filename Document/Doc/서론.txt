게임과 같은 실시간 렌더링 환경에서는 높은 품질의 렌더링 된 장면을 실시간으로 보여줘야 하기 때문에 정해진 시간(60hz or 144hz)안에 렌더링을 끝내기 위해 오래 걸리는 계산을 간략화 하거나 생략한다. 이렇게 생략되는 부분에는 파티클 충돌이 포함되어 있는 경우가 많이 존재한다. 
시간이 지남에 따라 그래픽 프로세서의 성능이 점점 더 좋아져 짧은 시간 내에 더 많은 계산을 처리할 수 있게 되었지만, 향상된 그래픽 프로세서를 사용해도 물리처리와 같이 계산이 필요한 객체가 많아질수록 계산량이 기하급수적으로 증가하는 문제를 실시간으로 처리하기에는 부족하다. 이러한 문제를 해결하기 위해 octal tree, binary space partition, kd tree[1]와 같은 알고리즘을 이용해 3차원의 공간을 분할하여 한 번에 처리해야 할 객체의 수를 줄여 계산량을 줄일 수 있는 방식이 제안되었고 사용되어 왔다. 
움직임이 정확하게 계산되지 않아도 게임 플레이에 큰 영향을 주지 않는 파티클 이펙트 렌더링의 경우 Screen Space Depth Buffer Based Collision [2,3]과 같은 연구를 통해 정확도가 떨어지는 대신 더 빠르게 계산할 수 있는 방법이 제안되었다. 그러나 해당 방식은 파티클과 지오메트리 오브젝트에 대한 충돌 검사이며, 여전히 파티클 간의 충돌 처리처럼 한 장면에서 계산해야 할 객체가 많은 경우는 성능에 대한 부하가 높아 객체의 개수를 줄이거나 제한된 경우에만 충돌계산을 하여 계산량을 줄이는 것이 일반적으로 사용되며 또한 시각적으로 큰 문제가 없는 경우에는 충돌 처리를 진행하지 않는 경우도 존재한다. 
본 논문에서는 기존에 사용되던 오브젝트와 파티클 간의 충돌 처리와 함께 사용될 수 있는 많은 수의 파티클 간의 실시간 충돌 처리에 대한 새로운 방식을 제시한다. 
본 논문에서 사용된 파티클 시스템은 OpenGL이 제공하는 Transform Feedback 기능을 이용하여 CPU는 파티클 정점의 초기화 부분에서만 데이터에 관여한다. 파티클 정점들은 Transform Feedback Buffer가 생성될 때 초기화된 후 그래픽스 파이프라인에 바인딩 된 이후에는 OpenGL에서 제공되는 Transform Feedback 기능을 통해서만 갱신된다. 
연구 프로젝트는 OpenGL로 진행하였고, 충돌 처리 패스와 렌더링 패스를 사용하는 2단계 알고리즘으로 구성되어있다.  첫번째 단계의 초기화시 충돌 감지 텍스처가 생성되지 않았기 때문에 충돌이 진행되지 않고 파티클의 업데이트만 진행되며 이때 충돌 감지 텍스처가 생성된다. 초기화 이후 프레임에서는 정점 셰이더에 입력된 데이터를 각 원소에1을 더하고 2로 나누어 텍스처 좌표(Texture Coordinate)로 변경하고 해당 좌표 값에 충돌 감지 텍스처의 가로, 세로의 크기를 곱하여 현재 파티클의 텍셀을 구한다. 정점 셰이더에서 TexelFetch기능을 이용하여 충돌 감지 텍스처에 저장된 위치 값을 읽어온다. 미리 설정해둔 기준 텍셀 주변의 탐색 범위를 샘플링하며 해당 범위 내에 위치 값을 변환하여 현재의 파티클 위치와의 거리를 계산하여 비교한다. 
충돌 단계의 기하 셰이더(Geometry Shader)에서는 Transform Feedback 기능을 통해 파티클 정점이 저장되어 있는 Transform Feedback Buffer Object를 갱신하며, 프래그먼트 셰이더(Fragment Shader)에서 파티클 정점의 위치를 출력 값으로 하여 충돌 탐지 텍스처를 갱신한다.
렌더링 단계의 정점 셰이더는 갱신된 Transform Feedback Buffer Object를 입력 정점 버퍼로 사용하며, 기하셰이더를 통하여 입력된 정점 데이터를 빌보드 형태로 변경한다. 이후 프래그먼트 셰이더에서 충돌한 파티클의 색상을 빨간색으로 그리고 그외의 파티클은 녹색으로 렌더링한다. 
결과적으로 본 논문에서 제안한 알고리즘을 이용해 평균적으로 125,000만개의 파티클간의 충돌처리를 71 ms 안에 처리할 수 있었다.
본 논문의 구성은 다음과 같다. 제2절에서는 관련연구에 대해 설명한다. 제3절에서는 연구에 사용된 파티클 시스템 및 파티클간 충돌처리 시스템에 대해 설명하고, 제4절에서는 제안한 기술을 이용한 파티클 개수와 파티클 밀도 차이에 따른 성능 측정 데이터를 보이며, 제5절에서는 결론 및 문제점과 향후 연구방향을 설명한다. 




첫 단계는 파티클의 업데이트 및 충돌을 처리하고 파티클의 월드 공간 위치(World Space Position)을 저장한 충돌 감지 텍스처(Collision Detection Texture)를 만든다. 

초기화 단계에서는 CPU를 통해 정점 데이터(Vertex Data)를 입력으로 받으며 업데이트를 진행한다. 첫 프레임에는 충돌 감지 텍스처가 생성되지 않았기 때문에 충돌처리가 진행되지 않고 파티클의 업데이트만 진행한다. 초기화 이후 프레임에서는 입력된 데이터를 텍스처 좌표(Texture Coordinate)로 변경하고 해당 좌표 값을 통해 충돌 감지 텍스처에 저장된 위치 값을 읽어온다. 미리 설정해둔 기준 텍셀 주변의 탐색 범위를 샘플링하며 해당 범위 내에 위치 값을 변환하여 현재의 파티클 위치와의 거리를 계산하여 비교한다. 그중 가장 작은 값과 충돌을 진행한다. 충돌을 통해 변화되는 값은 업데이트 되어 다음 단계에서 입력으로 사용된다. 두번째 단계는 첫번째 단계에서 업데이트된 정보를 이용하여 기하 셰이더(Geometry Shader)를 통해 빌보드 형태로 변형하여 파티클을 그려주는 단계를 거친다. 이때 충돌된 파티클의 색상을 변화시킨다. 

사용한 파티클 시스템은 OpenGL의 Transform Feedback 기능을 이용하여 초기화를 제외하고 GPU에서 업데이트 된다. 해당 기능은 정점 셰이더(Vertex Shader)의 출력을 Transform Feedback Buffer Object로 지정한 Buffer Object에 Capturing 하게 되며, 해당 Output Buffer는 다음 그리기(draw)에 정점 데이터의 입력으로 사용하여 GPU를 통한 업데이트를 진행할 수 있도록 한다. 
